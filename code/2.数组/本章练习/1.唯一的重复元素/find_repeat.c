/******************************************************************************
 *  题目说明：将1~1000放在含有1001个元素的数组中，只有唯一的一个元素重复，其他均
            只出现一次。请设计一个算法，将这个唯一重复的元素找出来，要求每个数组元素
            只能访问一次，且不能使用辅助存储空间。
    解法1：  把所有的数相加然后减去1-1000的和，差值就是重复的数字
    解法2：  利用下标与单元中所存储的内容之间的特殊关系，进行遍历访问单元，一旦访问过的单
            元赋予一个标记，利用标记作为发现重复数字的关键
    扩展：  对于一个既定的自然数 N ，有一个 N + M 个元素的数组，其中存放了小于等于 N 的所有
           自然数，求重复出现的自然数序列 {X} 。 
    解法： 对解法二进行扩展
    参考： https://blog.csdn.net/fengsanshao/article/details/1531670
******************************************************************************/
#include <stdio.h>

int find(int *a)
{
    int sum = 0;

    for (int i = 0; i < 1001; i++)
    {
        sum += a[i];
    }

    return (sum - (1000+1)*1000/2);
}

/**
 * @函数名称: findRepeat
 * @功能描述: 对于一个既定的自然数 N ，有一个 N + M 个元素的数组，其中存放了小于等于 N 的所有
             自然数，求重复出现的自然数序列 {X} 
 */
void findRepeat(int *a, int N, int M)
{
    int index;

    index = a[N+M-1] -1;
    while(1)
    {
        if (a[index] < 0)
        {
            printf("repeat number:%d\n",index+1);
            M--;
            if (0 == M)
                return;
            index = a[N+M-1] - 1;
        }
        if (a[index] > 0)
            a[index] *= -1;
        index = a[index] * (-1) - 1;
    }
}

int main()
{
    int tst[13]={1,2,10,8,4,3,5,8,7,6,9,4,2};

	findRepeat(tst,10,3);
	return 0;
}