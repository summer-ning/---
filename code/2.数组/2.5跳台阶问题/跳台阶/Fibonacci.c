/******************************************************************************
 *  题目说明：一个台阶总共有n 级，如果一次可以跳1 级，也可以跳2 级。
            求总共有多少总跳法，并分析算法的时间复杂度。
    解法：如果只有1级台阶，那显然只有一种跳法。如果有2级台阶，那就有两种跳的方法了：
         一种是分两次跳，每次跳1级；另外一种就是一次跳2级。
         在我们再来讨论一般情况。我们把n级台阶时的跳法看成是n的函数，记为f(n)
         当n>2时，第一次跳的时候就有两种不同的选择：
            一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；
            另外一种选择是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)
         因此n级台阶时的不同跳法的总数f(n)=f(n-1)+f(n-2)
         原来上述问题就是我们平常所熟知的Fibonacci数列问题
         代码有两种方式实现：递归和递推计算，不推荐递归方式，太多的重复计算，耗时耗资源
******************************************************************************/
#include <stdio.h>

// 递归算法
int climbStairs_recursion(int n)
{
    if (n <= 2)
    {
        return n;
    }

    return climbStairs_recursion(n - 1) + climbStairs_recursion(n - 2);
}

// 递推计算
int climbStairs(int n)
{
    int dp[3] = {1,1,0};

    if (n < 2)
        return n;
    for (int i = 2; i <= n; i++)
    {
        dp[2] = dp[0] + dp[1];
        dp[0] = dp[1];
        dp[1] = dp[2];
    }
    return dp[2];
}

int main()
{
    int r1, r2;
    for (int i = 1; i < 30; i++)
    {
        r1 = climbStairs_recursion(i);
        r2 = climbStairs(i);
        if (r1 != r2)
        {
            printf("ERROR!! r1=%d,r2=%d\n",r1,r2);
            break;
        }
    }
    return 0;
}
